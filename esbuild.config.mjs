import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import fs from "fs";
import path from "path";
import fsExtra from 'fs-extra';

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === "production";
const isCI = process.env.CI === 'true';

// --- Read README content --- START ---
const readmePath = path.resolve('README.md'); // Get absolute path to README
let readmeContent = '';
try {
	readmeContent = fs.readFileSync(readmePath, 'utf-8');
	console.log('Read README.md for embedding.');
} catch (err) {
	console.error('Failed to read README.md for embedding:', err);
	readmeContent = 'Error: Could not load README content.'; // Fallback content
}
// --- Read README content --- END ---

// Define source and destination paths
const sourceDir = ".";
let destDirs = [];

// Use a relative output directory when running in CI
if (isCI) {
	destDirs = ["./build"];
} else {
	// Local development paths
	destDirs = [
		"/Users/ericrhystaylor/Documents/Author/Author Obsidian Vault .nosync/.obsidian/plugins/radial-timeline",
		"/Users/ericrhystaylor/Documents/Code Projects/Test Obsidian Vault/.obsidian/plugins/radial-timeline",
		"/Users/ericrhystaylor/Documents/Code Projects/Test Obsidian Vault Jane Austin/.obsidian/plugins/radial-timeline",
		"./release"  // Add release folder for distribution
	];
}

// Files to copy from src/ (in addition to the built JS)
const filesToCopy = [
	"manifest.json",
	"styles.css",
	// "screenshot.jpeg" // Removed as it should be referenced via absolute URL in README
];

// Function to copy build assets to destination directories
async function copyBuildAssets() {
	for (const destDir of destDirs) {
		// Ensure the destination directory exists
		if (!fs.existsSync(destDir)) {
			fs.mkdirSync(destDir, { recursive: true });
		}
		
		// --- Copy individual files ---
		for (const file of filesToCopy) {
			const sourcePath = path.join(sourceDir, "src", file);
			const destPath = path.join(destDir, file);
			
			// Check if source file exists
			if (fs.existsSync(sourcePath)) {
				try {
					// Create destination directory if it doesn't exist
					if (!fs.existsSync(path.dirname(destPath))) {
						fs.mkdirSync(path.dirname(destPath), { recursive: true });
					}
					
					// Copy the file
					fs.copyFileSync(sourcePath, destPath);
				} catch (err) {
					console.error(`Error copying ${file} to ${destDir}:`, err);
				}
			} else {
				console.warn(`Warning: ${sourcePath} does not exist, skipping.`);
			}
		}
		
		// --- Copy main.js ---
		if (destDirs.length > 1) {
			const mainJsPath = path.join(destDirs[0], "main.js");
			if (fs.existsSync(mainJsPath) && destDir !== destDirs[0]) {
				try {
					fs.copyFileSync(mainJsPath, path.join(destDir, "main.js"));
				} catch (err) {
					console.error(`Error copying main.js to ${destDir}:`, err);
				}
			}
		}
	}
	
	// Keep root manifest.json in sync for submission tooling
	try {
		const srcManifest = path.join(sourceDir, "src", "manifest.json");
		if (fs.existsSync(srcManifest)) {
			fs.copyFileSync(srcManifest, path.join(sourceDir, "manifest.json"));
		}
	} catch (err) {
		console.error("Error syncing manifest.json to project root:", err);
	}
	
	// Note: Release files are now maintained in the release/ folder
	// No need to copy to project root since release/ is the source of truth
	
	console.log(`Build assets copied to: ${destDirs.join(", ")}`);
}

const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ['src/main.ts'],
	bundle: true,
	external: [
		'obsidian',
		'electron',
		'codemirror',
		'@codemirror/autocomplete',
		'@codemirror/collab',
		'@codemirror/commands',
		'@codemirror/language',
		'@codemirror/lint',
		'@codemirror/search',
		'@codemirror/state',
		'@codemirror/view',
		...builtins,
	],
	format: 'cjs',
	target: 'es2018',
	logLevel: 'info',
	sourcemap: prod ? false : 'inline',
	treeShaking: true,
	outdir: destDirs[0],
	define: {
		'EMBEDDED_README_CONTENT': JSON.stringify(readmeContent),
		'process.env.NODE_ENV': JSON.stringify(prod ? 'production' : 'development')
	}
});

if (prod) {
	await context.rebuild();
	await copyBuildAssets();
	console.log("Production build complete!");
	await context.dispose(); // Gracefully dispose of the context
} else {
	await context.watch();
	// Copy files initially
	await copyBuildAssets();
	console.log("Watching for changes...");
	
	// Set up file watchers for non-TS files
	filesToCopy.forEach(file => {
		const sourcePath = path.join(sourceDir, "src", file);
		fs.watch(sourcePath, async () => {
			try {
				// Update file in all destination directories
				for (const destDir of destDirs) {
					const destPath = path.join(destDir, file);
					fs.copyFileSync(sourcePath, destPath);
				}
				// Also sync root manifest.json on change
				if (file === "manifest.json") {
					try {
						fs.copyFileSync(sourcePath, path.join(sourceDir, "manifest.json"));
					} catch (e) {
						console.error("Error syncing root manifest.json on change:", e);
					}
				}
				console.log(`Files updated in all destination directories`);
			} catch (err) {
				console.error(`Error updating ${file}:`, err);
			}
		});
	});

	// Watch for main.js changes (the output file) and copy to other destinations
	const mainJsPath = path.join(destDirs[0], "main.js");
	fs.watch(mainJsPath, async () => {
		try {
			// Copy to all other destination directories
			for (let i = 1; i < destDirs.length; i++) {
				fs.copyFileSync(mainJsPath, path.join(destDirs[i], "main.js"));
			}
			console.log(`main.js updated in all destination directories`);
		} catch (err) {
			console.error(`Error updating main.js:`, err);
		}
	});
}
