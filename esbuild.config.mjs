import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import fs from "fs";
import path from "path";
import fsExtra from 'fs-extra';
import { bundleCSS } from './scripts/bundle-css.mjs';

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === "production";
const isCI = process.env.CI === 'true';

// --- Read README content --- START ---
const readmePath = path.resolve('README.md'); // Get absolute path to README
let readmeContent = '';
try {
	readmeContent = fs.readFileSync(readmePath, 'utf-8');
	// console.log('Read README.md for embedding.'); // Suppressed for cleaner build output
} catch (err) {
	logErrorDetails('Failed to read README.md for embedding:', err);
	readmeContent = 'Error: Could not load README content.'; // Fallback content
}
// --- Read README content --- END ---


// --- Read release notes content REMOVED: Managed via direct import in code ---

// Define source and destination paths
const sourceDir = ".";
let destDirs = [];

function logErrorDetails(context, err) {
	console.error(context);
	console.error('  err:', err);
	console.error('  err.code:', err?.code ?? 'n/a');
	console.error('  err.path:', err?.path ?? 'n/a');
	const esbuildErrors = err?.errors;
	if (Array.isArray(esbuildErrors)) {
		esbuildErrors.forEach((esErr, index) => {
			console.error(`  err.errors[${index}]:`, esErr);
			if (esErr?.detail) {
				console.error(`    detail.code: ${esErr.detail.code ?? 'n/a'}`);
				console.error(`    detail.path: ${esErr.detail.path ?? 'n/a'}`);
			}
		});
	} else if (esbuildErrors) {
		console.error('  err.errors:', esbuildErrors);
	}
}

function verifyWritableDir(dir) {
	try {
		if (!fs.existsSync(dir)) {
			fs.mkdirSync(dir, { recursive: true });
		}
		const testFilePath = path.join(dir, '.codex-write-test');
		fs.writeFileSync(testFilePath, 'write-test');
		fs.unlinkSync(testFilePath);
		return true;
	} catch (err) {
		logErrorDetails(`Unable to verify write access to ${dir}`, err);
		return false;
	}
}

// Use a relative output directory when running in CI
if (isCI) {
	destDirs = ["./build"];
} else {
	// Local development paths
	destDirs = [
		"/Users/ericrhystaylor/Documents/Author/Author Obsidian Vault .nosync/.obsidian/plugins/radial-timeline",
		"/Users/ericrhystaylor/Documents/Code Projects/Obsidian Vault Fresh/.obsidian/plugins/radial-timeline",
		"./release"  // Add release folder for distribution
	];
}

destDirs.forEach(dir => verifyWritableDir(dir));

// Files to copy from src/ (in addition to the built JS)
const filesToCopy = [
	"manifest.json",
	"styles.css",
	// "screenshot.jpeg" // Removed as it should be referenced via absolute URL in README
];

// Function to copy build assets to destination directories
async function copyBuildAssets() {
	try {
		await bundleCSS();
	} catch (err) {
		logErrorDetails('Error bundling CSS:', err);
	}

	for (const destDir of destDirs) {
		// Ensure the destination directory exists
		try {
			if (!fs.existsSync(destDir)) {
				fs.mkdirSync(destDir, { recursive: true });
			}
		} catch (err) {
			logErrorDetails(`Error ensuring destination directory ${destDir}`, err);
			continue;
		}

		// --- Copy individual files from src/ ---
		for (const file of filesToCopy) {
			const sourcePath = path.join(sourceDir, "src", file);
			const destPath = path.join(destDir, file);

			// Check if source file exists
			if (fs.existsSync(sourcePath)) {
				try {
					// Create destination directory if it doesn't exist
					if (!fs.existsSync(path.dirname(destPath))) {
						fs.mkdirSync(path.dirname(destPath), { recursive: true });
					}

					// Copy the file
					fs.copyFileSync(sourcePath, destPath);
				} catch (err) {
					logErrorDetails(`Error copying ${file} to ${destDir}:`, err);
				}
			} else {
				console.warn(`Warning: ${sourcePath} does not exist, skipping.`);
			}
		}

		// --- Copy main.js ---
		if (destDirs.length > 1) {
			const mainJsPath = path.join(destDirs[0], "main.js");
			if (fs.existsSync(mainJsPath) && destDir !== destDirs[0]) {
				try {
					fs.copyFileSync(mainJsPath, path.join(destDir, "main.js"));
				} catch (err) {
					logErrorDetails(`Error copying main.js to ${destDir}:`, err);
				}
			}
		}
	}

	// Keep root manifest.json in sync for submission tooling
	try {
		const srcManifest = path.join(sourceDir, "src", "manifest.json");
		if (fs.existsSync(srcManifest)) {
			fs.copyFileSync(srcManifest, path.join(sourceDir, "manifest.json"));
		}
	} catch (err) {
		logErrorDetails("Error syncing manifest.json to project root:", err);
	}

	// Note: Release files are now maintained in the release/ folder
	// No need to copy to project root since release/ is the source of truth

	// Show full destination paths, one per line for better readability
	console.log('Build assets copied to:');
	destDirs.forEach(dir => console.log(`  ${dir}`));
}

const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ['src/main.ts'],
	bundle: true,
	external: [
		'obsidian',
		'electron',
		'codemirror',
		'@codemirror/autocomplete',
		'@codemirror/collab',
		'@codemirror/commands',
		'@codemirror/language',
		'@codemirror/lint',
		'@codemirror/search',
		'@codemirror/state',
		'@codemirror/view',
		...builtins,
	],
	format: 'cjs',
	target: 'es2018',
	logLevel: 'info',
	sourcemap: prod ? false : 'inline',
	treeShaking: true,
	outdir: destDirs[0],
	define: {
		'EMBEDDED_README_CONTENT': JSON.stringify(readmeContent),
		// 'EMBEDDED_RELEASE_NOTES': // REMOVED: Managed via direct import in code
		'process.env.NODE_ENV': JSON.stringify(prod ? 'production' : 'development')
	}
});

if (prod) {
	try {
		await context.rebuild();
	} catch (err) {
		logErrorDetails('esbuild production rebuild failed:', err);
		throw err;
	}
	await copyBuildAssets();
	console.log("Production build complete!");
	await context.dispose(); // Gracefully dispose of the context
} else {
	try {
		await context.watch();
	} catch (err) {
		logErrorDetails('Failed to start esbuild watch mode:', err);
		throw err;
	}
	// Copy files initially
	await copyBuildAssets();
	console.log("Watching for changes...");

	// Set up file watchers for non-TS files
	filesToCopy.forEach(file => {
		const sourcePath = path.join(sourceDir, "src", file);
		fs.watch(sourcePath, async () => {
			try {
				// Update file in all destination directories
				for (const destDir of destDirs) {
					const destPath = path.join(destDir, file);
					fs.copyFileSync(sourcePath, destPath);
				}
				// Also sync root manifest.json on change
				if (file === "manifest.json") {
					try {
						fs.copyFileSync(sourcePath, path.join(sourceDir, "manifest.json"));
					} catch (e) {
						logErrorDetails("Error syncing root manifest.json on change:", e);
					}
				}
				console.log(`Files updated in all destination directories`);
			} catch (err) {
				logErrorDetails(`Error updating ${file}:`, err);
			}
		});
	});

	// Watch src/styles for changes
	const stylesDir = path.join(sourceDir, "src", "styles");
	if (fs.existsSync(stylesDir)) {
		fs.watch(stylesDir, { recursive: true }, async (eventType, filename) => {
			if (filename && filename.endsWith('.css')) {
				console.log(`Style change detected in ${filename}, rebundling...`);
				try {
					await copyBuildAssets();
				} catch (err) {
					console.error('Error rebundling styles:', err);
				}
			}
		});
	}

	// Watch for main.js changes (the output file) and copy to other destinations
	const mainJsPath = path.join(destDirs[0], "main.js");
	fs.watch(mainJsPath, async () => {
		try {
			// Copy to all other destination directories
			for (let i = 1; i < destDirs.length; i++) {
				fs.copyFileSync(mainJsPath, path.join(destDirs[i], "main.js"));
			}
			console.log(`main.js updated in all destination directories`);
		} catch (err) {
			logErrorDetails(`Error updating main.js:`, err);
		}
	});
}
